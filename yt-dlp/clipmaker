#!/usr/bin/env -S python -u

import argparse
import datetime as dt
from functools import cached_property
import json
import os
from pathlib import Path
import re
import subprocess
import time
from typing import Any
import urllib.parse as urlp

from yt_dlp import YoutubeDL

FFMPEG_CMD = """ffmpeg -hide_banner -loglevel warning -stats {y} {start} {to}
-i {stream} {end} -c copy -avoid_negative_ts make_zero {output}"""
FFMPEG_CMD_YT = """ffmpeg -hide_banner -loglevel warning -stats {y} {start} {to}
    -i {v_stream} {start} {to} -i {a_stream} {end} -map 0:v -map 1:a -avoid_negative_ts make_zero {output}"""

YT_FMT_PAIR_PATTERN = r"^\d{2,3}\+\d{2,3}(?:\-\d+)?$"

DEFAULT_RESOLUTION = "1280x720"
CACHE_HOME = (
    Path(os.environ.get("XDG_CACHE_HOME", Path.home() / ".cache")) / "clipmaker"
)
if not CACHE_HOME.exists():
    CACHE_HOME.mkdir(exist_ok=True)


def parse_agrs() -> argparse.Namespace:
    rx_timestamp = re.compile(
        r"^(\d+|\d:[0-5]\d|[0-5]?\d:[0-5]\d|\d+:[0-5]\d:[0-5]\d)$"
    )

    def validate_timestamp(timestamp: str | None = None) -> str | None:
        if timestamp is not None and not rx_timestamp.match(timestamp):
            raise argparse.ArgumentTypeError("invalid timestamp %r" % timestamp)
        return timestamp

    def validate_resolution(resolution: str) -> str | None:
        if not re.match(r"^\d{3,4}x\d{3,4}$", resolution):
            raise argparse.ArgumentTypeError("invalid resolution %r" % resolution)
        return resolution

    parser = argparse.ArgumentParser(
        prog="clipmaker",
        description="Download clips from YouTube or Twitch",
    )
    parser.add_argument("url", metavar="URL")
    parser.add_argument(
        "-s",
        "--start",
        type=validate_timestamp,
        metavar="T",
        help="clip start time (59/9:59/9:59:59)",
    )
    parser.add_argument(
        "-d",
        "--duration",
        type=validate_timestamp,
        metavar="T",
        help="clip duration (59/9:59/9:59:59)",
    )
    parser.add_argument(
        "-t",
        "--to",
        type=validate_timestamp,
        metavar="T",
        help="clip stop time (59/9:59/9:59:59)",
    )
    parser.add_argument(
        "-r",
        "--resolution",
        type=validate_resolution,
        default=DEFAULT_RESOLUTION,
        help=f"clip resolution (default: %(default)s)",
    )
    parser.add_argument(
        "-o",
        "--output",
        default=f"clip{time.strftime('%s')}.mp4",
        metavar="PATH",
        help="output path (default: %(default)s)",
    )
    parser.add_argument(
        "-F",
        "--force",
        action="store_true",
        help="overwrite output file if exists",
    )
    parser.add_argument(
        "-c", "--choose", action="store_true", help="print available formats to choose"
    )
    parser.add_argument(
        "-f",
        "--format",
        help=f"formats pair string",
    )
    parser.add_argument(
        "-O",
        "--overwrite-cache",
        action="store_true",
        help="overwrite cached video info if exists",
    )
    return parser.parse_args()


class Clipmaker:
    def __init__(
        self,
        *,
        url: str,
        output: str,
        choose: bool = False,
        force: bool = False,
        overwrite_cache: bool = False,
        format: str | None = None,
        start: str | None = None,
        duration: str | None = None,
        to: str | None = None,
        resolution: str | None = None,
    ) -> None:
        self.start = start
        self.is_yt = False
        self.url = self._clean_url(url)
        self.output = output
        self.choose = choose
        self.force = force
        self.format = format
        self.duration = duration
        self.to = to
        self.resolution = resolution
        self.format_id: str = ""
        self.overwrite_cache = overwrite_cache

    def build_cmd(self) -> str:
        url = v_url = a_url = ""
        ffmpeg_cmd = FFMPEG_CMD

        def choose():
            nonlocal url, v_url, a_url
            self.print_formats_table()
            while True:
                inp = input("choose format: ")
                if re.match(YT_FMT_PAIR_PATTERN, inp):
                    v, a = inp.split("+")
                    if self.check_formats_pair(v, a):
                        v_url = self.formats_map[v]["url"]
                        a_url = self.formats_map[a]["url"]
                        break
                elif inp in self.formats_map:
                    url = self.formats_map[inp]["url"]
                    break
                else:
                    print(f"invalid format {inp!r}")

        if self.choose:
            choose()
        elif not self.is_yt or (
            self.format and not re.match(YT_FMT_PAIR_PATTERN, self.format)
        ):
            url = self.get_stream()
        elif self.resolution and (purl := self.premuxed_url()):
            url = purl
        else:
            ffmpeg_cmd = FFMPEG_CMD_YT
            v_url, a_url = self.get_yt_streams()

        if len(url + v_url + a_url) == 0:
            choose()

        return ffmpeg_cmd.format(
            y="-y" if self.force else "",
            start="-ss %s" % (self.start or 0),
            to=f"-to {self.to}" if self.to else "",
            stream=url,
            v_stream=v_url,
            a_stream=a_url,
            end=f"-t {self.duration}" if self.duration else "",
            output=self.output,
        )

    def get_stream(self) -> str:
        if self.format:
            if f := self.formats_map.get(self.format):
                return f["url"]
            print(f"format {self.format!r} not found")
        for f in self.formats_map.values():
            if f.get("resolution") == self.resolution and f.get("acodec") is not None:
                return f["url"]
        else:
            print(f"resolution {self.resolution!r} not found")
            return ""

    def get_yt_streams(self) -> tuple[str, str]:
        _ = self.formats_map
        if self.resolution:
            return self.yt_streams_by_resolution()
        elif not self.format:
            self.format = self.format_id
        v, a = self.format.split("+")
        if not self.check_formats_pair(v, a):
            exit(1)

        return self.formats_map[v]["url"], self.formats_map[a]["url"]

    def yt_streams_by_resolution(self) -> tuple[str, str]:
        v = ""
        a = ""
        if len(self.format_id.split("+")) == 2:
            _, af = self.format_id.split("+")
            a = self.formats_map.get(af, {"url": ""})["url"]
        for f in self.formats_map.values():
            if not v and self.resolution == f.get("resolution", "-"):
                v = f["url"]
                break
            if not a and f.get("resolution", "-") == "audio only":
                a = f["url"]
        else:
            exit(f"resolution {self.resolution!r} not found")

        return v, a

    @cached_property
    def formats_map(self) -> dict[str, Any]:
        if not self.overwrite_cache and (c := self.read_cache()):
            if not self.is_yt or not is_format_expired(c):
                return c
        with YoutubeDL() as ydl:
            info = ydl.extract_info(self.url, download=False)
            if not info or not isinstance(info, dict):
                exit("can't extract info")
            if not info.get("formats"):
                exit("can't get formats from info")

            self.format_id = info.get("format_id", "")
            fm = {
                f["format_id"]: {
                    "format_id": f["format_id"],
                    "url": f["url"],
                    "resolution": f["resolution"],
                    "ext": f["ext"],
                    "vcodec": f["vcodec"],
                    "acodec": f["acodec"],
                }
                for f in filter(filter_format, info["formats"])
            }
            self.write_cache(fm)
            return fm

    def print_formats_table(self) -> None:
        with YoutubeDL() as ydl:
            print(ydl.render_formats_table({"formats": self.formats_map.values()}))

    def check_formats_pair(self, v: str, a: str) -> bool:
        for f in [v, a]:
            if f not in self.formats_map:
                print(f"format {f!r} not found")
                return False
        return True

    def premuxed_url(self) -> str | None:
        for f in self.formats_map.values():
            if (
                f.get("vcodec")
                and f.get("acodec")
                and f.get("acodec") != "none"
                and f.get("resolution") == self.resolution
            ):
                return f.get("url")

    def _clean_url(self, url: str) -> str:
        u = urlp.urlparse(url)
        if u.hostname is None:
            raise ValueError(f"Invalid url {url!r}")
        if u.hostname.endswith("youtu.be") or u.hostname.endswith("youtube.com"):
            self.is_yt = True
        elif not u.hostname.endswith("twitch.tv"):
            return url

        params = {
            k: v[0]
            for k, v in urlp.parse_qs(u.query).items()
            if k in ("v", "t") and len(v) == 1
        }

        if u.hostname.endswith("youtube.com") and not "v" in params:
            raise ValueError(f"Invalid url {self.url!r}")

        if self.start is None and "t" in params:
            t = params["t"]
            if u.hostname.endswith("twitch.tv"):
                self.start = t.replace("h", ":").replace("m", ":").replace("s", "")
            else:
                self.start = t

        return urlp.urlunparse(
            (u.scheme, u.netloc, u.path, u.params, urlp.urlencode(params), u.fragment)
        )

    @cached_property
    def cache_file(self) -> Path:
        id_ = None
        if m := re.match(
            r".*youtu(\.be/|be\.com/watch\?v=|be\.com/shorts/)([-_0-9a-zA-Z]{11})",
            self.url,
        ):
            _, id_ = m.groups()
        elif m := re.match(r".*twitch\.tv/videos/(\d{10})", self.url):
            (id_,) = m.groups()
        else:
            id_ = self.url
        return CACHE_HOME / id_.replace("/", "")

    def read_cache(self) -> dict[str, Any] | None:
        if self.cache_file.exists():
            return json.load(self.cache_file.open())

    def write_cache(self, info: dict[str, Any]):
        with open(self.cache_file, "w") as f:
            json.dump(info, f)


def is_format_expired(d: dict[str, dict]) -> bool:
    try:
        (f, *_) = d.values()
        m = re.search(r"expire=(\d{10})", f["url"])
        if not m or len(m.groups()) != 1:
            return True
        expired_at = dt.datetime.fromtimestamp(float(m.groups()[0])) + dt.timedelta(
            minutes=1
        )
        return expired_at < dt.datetime.now()
    except:
        return True


def filter_format(formats: dict[str, Any]) -> bool:
    filters = {"ext": "mhtml", "format_note": "storyboard"}
    for k, v in filters.items():
        if formats.get(k) == v:
            return False
    return True


def main():
    args = parse_agrs()
    subprocess.run(Clipmaker(**vars(args)).build_cmd().split())


if __name__ == "__main__":
    main()
