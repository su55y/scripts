#!/bin/sh
# shellcheck disable=SC2046,SC2086,SC2181,SC2329

input=
start=
duration=
to_pos=
ratio=
chapters=
show_chapters=0
output="clip$(date +%s).mp4"
ffmpeg_opts=
y_=0

show_help() {
    cat <<EOF
usage: $(basename "$0") [-c C] [-C] [-d T] [-i FILE] [-r FLOAT] [-s T] [-t T] [-o FILE] [-O OPTS] [-y]

-c chapters range (e.g. 1..4, 2.., 3)
-C show chapters list
-d duration timestamp
-i input file (required)
-r speed ratio
-s start timestamp
-t to position timestamp
-o output file (default: $output)
-O ffmpeg output opts
-y execute ffmpeg cmd without asking
EOF
}

parse_args() {
    OPTIND=1
    while getopts 'c:d:i:o:r:s:t:O:yC' opt; do
        case $opt in
        c) chapters=$OPTARG ;;
        C) show_chapters=1 ;;
        d) duration=$OPTARG ;;
        i) input=$OPTARG ;;
        o) output=$OPTARG ;;
        O) ffmpeg_opts=$OPTARG ;;
        r) ratio=$OPTARG ;;
        s) start=$OPTARG ;;
        t) to_pos=$OPTARG ;;
        y) y_=1 ;;
        *)
            show_help
            exit 0
            ;;
        esac
    done

    shift $((OPTIND - 1))
    [ "${1:-}" = '--' ] && shift
}

parse_args "$@"
if [ -z "$input" ]; then
    show_help
    exit 1
fi

chapters_file=
if [ -n "$chapters" ] || [ "$show_chapters" -eq 1 ]; then
    chapters_file=$(mktemp -t metadata.XXXXXXXXX)
    cleanup() {
        [ -f "$chapters_file" ] && rm "$chapters_file"
    }
    trap cleanup EXIT

    ffmpeg -y -v quiet -loglevel error -i "$input" -f ffmetadata "$chapters_file" || exit 1
fi

if [ -n "$chapters" ]; then
    c_start="${chapters%%..*}"
    [ -z "$c_start" ] && c_start=1
    c_to="${chapters##*..}"
    [ -z "$c_to" ] && c_to=0

    if [ -z "${c_start}${c_to}" ]; then
        echo "Invalid chapters range '$chapters'"
        exit 1
    fi

    is_header_done=0
    chapter_num=0
    timebase=

    while read -r line; do
        if [ "$line" = '[CHAPTER]' ]; then
            is_header_done=1
            chapter_num=$((chapter_num + 1))
            continue
        elif [ $is_header_done -eq 0 ]; then
            continue
        fi

        case $line in
        TIMEBASE=1/*) [ -z "$timebase" ] && timebase="${line##*/}" ;;
        START=*)
            if [ $c_start -eq $chapter_num ]; then
                start_="${line##*=}"
                start=$((start_ / timebase))
            fi
            ;;
        END=*)
            if [ $c_to -eq $chapter_num ]; then
                to_="${line##*=}"
                to_pos=$((to_ / timebase))
            fi
            ;;

        esac
    done <"$chapters_file"

elif [ "$show_chapters" -eq 1 ]; then
    d="$(ffprobe -v quiet -of csv=p=0 -show_entries format=duration "$input" | cut -d. -f1)"
    l=0 # %02M:%02S
    if [ $d -gt 86400 ]; then
        l=3 # %d %02H:%02M:%02S
    elif [ $d -gt 36000 ]; then
        l=2 # %02H:%02M:%02S
    elif [ $d -gt 3600 ]; then
        l=1 # %H:%02M:%02S
    fi

    sec_to_date() {
        v=${1:-0}
        d=$((v / 86400))
        h=$((v / 3600))
        m=$(((v % 3600) / 60))
        s=$((v % 60))
        case $l in
        0) printf '%02d:%02d\n' $m $s ;;
        1) printf '%d:%02d:%02d\n' $h $m $s ;;
        2) printf '%02d:%02d:%02d\n' $h $m $s ;;
        3) printf '%d %02d:%02d:%02d' $d $h $m $s ;;
        esac
    }

    cl="$(grep -c '\[CHAPTER\]' "$chapters_file")"
    if [ -z "$cl" ] || [ "$cl" = 0 ]; then
        echo "No chapters"
        exit 0
    fi
    cl=${#cl}

    start=0
    is_header_done=0
    chapter_num=0
    timebase=

    while read -r line; do
        if [ "$line" = '[CHAPTER]' ]; then
            is_header_done=1
            chapter_num=$((chapter_num + 1))
            continue
        elif [ $is_header_done -eq 0 ]; then
            continue
        fi

        case $line in
        TIMEBASE=1/*) [ -z "$timebase" ] && timebase="${line##*/}" ;;
        START=*)
            start_="${line##*=}"
            start=$((start_ / timebase))
            ;;
        title=*)
            timestamp="$(sec_to_date "$start")"
            title="${line##*=}"
            printf "%0${cl}d [%s] %s\n" $chapter_num "$timestamp" "$title"
            ;;

        esac
    done <"$chapters_file"
    exit 0
fi

if [ -z "${start}${duration}${to_pos}${ratio}" ]; then
    show_help
    exit 0
fi

cmd='ffmpeg -hide_banner -loglevel warning -stats'
if [ -n "$start" ]; then
    cmd="$cmd -ss $start"
fi

if [ -n "$to_pos" ]; then
    cmd="$cmd -to $to_pos -i '$input'"
elif [ -n "$duration" ]; then
    cmd="$cmd -i '$input' -t $duration"
else
    cmd="$cmd -i '$input'"
fi

if [ -n "$chapters" ]; then
    cmd="$cmd -map_metadata -1 -map_chapters -1"
fi

if [ -n "$ratio" ]; then
    probe="$(ffprobe -v quiet -show_streams -of json "$input")"
    if [ $? -ne 0 ]; then
        echo 'Probe failed'
        exit 1
    fi

    has_video=0
    if echo "$probe" | grep -q '"codec_type": "video"'; then
        has_video=1
    fi

    has_audio=0
    if echo "$probe" | grep -q '"codec_type": "audio"'; then
        has_audio=1
    fi

    if [ $has_video -eq 1 ] && [ $has_audio -eq 1 ]; then
        filter="-filter_complex '[0:v]setpts=PTS/${ratio}[v];[0:a]atempo=${ratio}[a]' -map [v] -map [a]"
    elif [ $has_video -eq 1 ]; then
        filter="-filter:v setpts=PTS/$ratio"
    elif [ $has_audio -eq 1 ]; then
        filter="-filter:a atempo=$ratio"
    else
        echo "No video or audio streams found in '$input'"
        exit 1
    fi
    cmd="$cmd $filter"
else
    cmd="$cmd -c copy"
fi

if [ -n "$ffmpeg_opts" ]; then
    cmd="$cmd $ffmpeg_opts $output"
else
    cmd="$cmd $output"
fi

if [ $y_ -ne 1 ]; then
    printf "%s\nExecute it? [Y/n]: " "$cmd"
    read -r answ
    case $answ in
    n* | N*) exit 0 ;;
    esac
else
    echo "$cmd"
fi

eval "$cmd"
